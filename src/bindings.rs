/* automatically generated by rust-bindgen 0.69.5 */

#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const BME280_STANDBY_TIME_0_5_MS: u32 = 0;
pub const BME280_STANDBY_TIME_62_5_MS: u32 = 1;
pub const BME280_STANDBY_TIME_125_MS: u32 = 2;
pub const BME280_STANDBY_TIME_250_MS: u32 = 3;
pub const BME280_STANDBY_TIME_500_MS: u32 = 4;
pub const BME280_STANDBY_TIME_1000_MS: u32 = 5;
pub const BME280_STANDBY_TIME_10_MS: u32 = 6;
pub const BME280_STANDBY_TIME_20_MS: u32 = 7;
pub const BME280_FILTER_COEFF_OFF: u32 = 0;
pub const BME280_FILTER_COEFF_2: u32 = 1;
pub const BME280_FILTER_COEFF_4: u32 = 2;
pub const BME280_FILTER_COEFF_8: u32 = 3;
pub const BME280_FILTER_COEFF_16: u32 = 4;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " SPI interface"]
pub const bme280_intf_BME280_SPI_INTF: bme280_intf = 0;
#[doc = " I2C interface"]
pub const bme280_intf_BME280_I2C_INTF: bme280_intf = 1;
#[doc = " @brief Interface selection Enums"]
pub type bme280_intf = ::std::os::raw::c_uint;
#[doc = " @brief Bus communication function pointer which should be mapped to\n the platform specific read functions of the user\n\n @param[in] reg_addr       : Register address from which data is read.\n @param[out] reg_data      : Pointer to data buffer where read data is stored.\n @param[in] len            : Number of bytes of data to be read.\n @param[in, out] intf_ptr  : Void pointer that can enable the linking of descriptors\n                             for interface related call backs.\n\n @retval   0 -> Success.\n @retval Non zero value -> Fail.\n"]
pub type bme280_read_fptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        reg_addr: u8,
        reg_data: *mut u8,
        len: u32,
        intf_ptr: *mut ::std::os::raw::c_void,
    ) -> i8,
>;
#[doc = " @brief Bus communication function pointer which should be mapped to\n the platform specific write functions of the user\n\n @param[in] reg_addr      : Register address to which the data is written.\n @param[in] reg_data      : Pointer to data buffer in which data to be written\n                            is stored.\n @param[in] len           : Number of bytes of data to be written.\n @param[in, out] intf_ptr : Void pointer that can enable the linking of descriptors\n                            for interface related call backs\n\n @retval   0   -> Success.\n @retval Non zero value -> Fail.\n"]
pub type bme280_write_fptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        reg_addr: u8,
        reg_data: *const u8,
        len: u32,
        intf_ptr: *mut ::std::os::raw::c_void,
    ) -> i8,
>;
#[doc = " @brief Delay function pointer which should be mapped to\n delay function of the user\n\n @param[in] period              : Delay in microseconds.\n @param[in, out] intf_ptr       : Void pointer that can enable the linking of descriptors\n                                  for interface related call backs\n"]
pub type bme280_delay_us_fptr_t =
    ::std::option::Option<unsafe extern "C" fn(period: u32, intf_ptr: *mut ::std::os::raw::c_void)>;
#[doc = " @brief Calibration data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bme280_calib_data {
    #[doc = " Calibration coefficient for the temperature sensor"]
    pub dig_t1: u16,
    #[doc = " Calibration coefficient for the temperature sensor"]
    pub dig_t2: i16,
    #[doc = " Calibration coefficient for the temperature sensor"]
    pub dig_t3: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p1: u16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p2: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p3: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p4: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p5: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p6: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p7: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p8: i16,
    #[doc = " Calibration coefficient for the pressure sensor"]
    pub dig_p9: i16,
    #[doc = " Calibration coefficient for the humidity sensor"]
    pub dig_h1: u8,
    #[doc = " Calibration coefficient for the humidity sensor"]
    pub dig_h2: i16,
    #[doc = " Calibration coefficient for the humidity sensor"]
    pub dig_h3: u8,
    #[doc = " Calibration coefficient for the humidity sensor"]
    pub dig_h4: i16,
    #[doc = " Calibration coefficient for the humidity sensor"]
    pub dig_h5: i16,
    #[doc = " Calibration coefficient for the humidity sensor"]
    pub dig_h6: i8,
    #[doc = " Variable to store the intermediate temperature coefficient"]
    pub t_fine: i32,
}
#[test]
fn bindgen_test_layout_bme280_calib_data() {
    const UNINIT: ::std::mem::MaybeUninit<bme280_calib_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bme280_calib_data>(),
        40usize,
        concat!("Size of: ", stringify!(bme280_calib_data))
    );
    assert_eq!(
        ::std::mem::align_of::<bme280_calib_data>(),
        4usize,
        concat!("Alignment of ", stringify!(bme280_calib_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_t1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_t1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_t2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_t2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_t3) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_t3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p3) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p4) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p5) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p6) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p7) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p8) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_p9) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_p9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_h1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_h1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_h2) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_h2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_h3) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_h3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_h4) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_h4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_h5) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_h5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dig_h6) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(dig_h6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_fine) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_calib_data),
            "::",
            stringify!(t_fine)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bme280_data {
    #[doc = " Compensated pressure"]
    pub pressure: f64,
    #[doc = " Compensated temperature"]
    pub temperature: f64,
    #[doc = " Compensated humidity"]
    pub humidity: f64,
}
#[test]
fn bindgen_test_layout_bme280_data() {
    const UNINIT: ::std::mem::MaybeUninit<bme280_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bme280_data>(),
        24usize,
        concat!("Size of: ", stringify!(bme280_data))
    );
    assert_eq!(
        ::std::mem::align_of::<bme280_data>(),
        8usize,
        concat!("Alignment of ", stringify!(bme280_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_data),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_data),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).humidity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_data),
            "::",
            stringify!(humidity)
        )
    );
}
#[doc = " @brief bme280 sensor structure which comprises of uncompensated temperature,\n pressure and humidity data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bme280_uncomp_data {
    #[doc = " Un-compensated pressure"]
    pub pressure: u32,
    #[doc = " Un-compensated temperature"]
    pub temperature: u32,
    #[doc = " Un-compensated humidity"]
    pub humidity: u32,
}
#[test]
fn bindgen_test_layout_bme280_uncomp_data() {
    const UNINIT: ::std::mem::MaybeUninit<bme280_uncomp_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bme280_uncomp_data>(),
        12usize,
        concat!("Size of: ", stringify!(bme280_uncomp_data))
    );
    assert_eq!(
        ::std::mem::align_of::<bme280_uncomp_data>(),
        4usize,
        concat!("Alignment of ", stringify!(bme280_uncomp_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_uncomp_data),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_uncomp_data),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).humidity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_uncomp_data),
            "::",
            stringify!(humidity)
        )
    );
}
#[doc = " @brief bme280 sensor settings structure which comprises of mode,\n oversampling and filter settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bme280_settings {
    #[doc = " Pressure oversampling"]
    pub osr_p: u8,
    #[doc = " Temperature oversampling"]
    pub osr_t: u8,
    #[doc = " Humidity oversampling"]
    pub osr_h: u8,
    #[doc = " Filter coefficient"]
    pub filter: u8,
    #[doc = " Standby time"]
    pub standby_time: u8,
}
#[test]
fn bindgen_test_layout_bme280_settings() {
    const UNINIT: ::std::mem::MaybeUninit<bme280_settings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bme280_settings>(),
        5usize,
        concat!("Size of: ", stringify!(bme280_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<bme280_settings>(),
        1usize,
        concat!("Alignment of ", stringify!(bme280_settings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).osr_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_settings),
            "::",
            stringify!(osr_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).osr_t) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_settings),
            "::",
            stringify!(osr_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).osr_h) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_settings),
            "::",
            stringify!(osr_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_settings),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).standby_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_settings),
            "::",
            stringify!(standby_time)
        )
    );
}
#[doc = " @brief bme280 device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bme280_dev {
    #[doc = " Chip Id"]
    pub chip_id: u8,
    #[doc = " Interface Selection\n For SPI, intf = BME280_SPI_INTF\n For I2C, intf = BME280_I2C_INTF"]
    pub intf: bme280_intf,
    #[doc = " The interface pointer is used to enable the user\n to link their interface descriptors for reference during the\n implementation of the read and write interfaces to the\n hardware."]
    pub intf_ptr: *mut ::std::os::raw::c_void,
    #[doc = " Variable to store result of read/write function"]
    pub intf_rslt: i8,
    #[doc = " Read function pointer"]
    pub read: bme280_read_fptr_t,
    #[doc = " Write function pointer"]
    pub write: bme280_write_fptr_t,
    #[doc = " Delay function pointer"]
    pub delay_us: bme280_delay_us_fptr_t,
    #[doc = " Trim data"]
    pub calib_data: bme280_calib_data,
}
#[test]
fn bindgen_test_layout_bme280_dev() {
    const UNINIT: ::std::mem::MaybeUninit<bme280_dev> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bme280_dev>(),
        88usize,
        concat!("Size of: ", stringify!(bme280_dev))
    );
    assert_eq!(
        ::std::mem::align_of::<bme280_dev>(),
        8usize,
        concat!("Alignment of ", stringify!(bme280_dev))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chip_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(chip_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intf) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(intf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intf_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(intf_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intf_rslt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(intf_rslt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay_us) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(delay_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calib_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bme280_dev),
            "::",
            stringify!(calib_data)
        )
    );
}
extern "C" {
    #[doc = " \\ingroup bme280ApiInit\n \\page bme280_api_bme280_init bme280_init\n \\code\n int8_t bme280_init(struct bme280_dev *dev);\n \\endcode\n @details This API reads the chip-id of the sensor which is the first step to\n verify the sensor and also calibrates the sensor\n As this API is the entry point, call this API before using other APIs.\n\n @param[in,out] dev : Structure instance of bme280_dev\n\n @return Result of API execution status.\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_init(dev: *mut bme280_dev) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiRegister\n \\page bme280_api_bme280_set_regs bme280_set_regs\n \\code\n int8_t bme280_set_regs(const uint8_t reg_addr, const uint8_t *reg_data, uint32_t len, struct bme280_dev *dev);\n \\endcode\n @details This API writes the given data to the register address of the sensor\n\n @param[in] reg_addr : Register addresses to where the data is to be written\n @param[in] reg_data : Pointer to data buffer which is to be written\n                       in the reg_addr of sensor.\n @param[in] len      : No of bytes of data to write\n @param[in,out] dev  : Structure instance of bme280_dev\n\n @return Result of API execution status.\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_set_regs(
        reg_addr: *mut u8,
        reg_data: *const u8,
        len: u32,
        dev: *mut bme280_dev,
    ) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiRegister\n \\page bme280_api_bme280_get_regs bme280_get_regs\n \\code\n int8_t bme280_get_regs(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, struct bme280_dev *dev);\n \\endcode\n @details This API reads the data from the given register address of sensor.\n\n @param[in] reg_addr  : Register address from where the data to be read\n @param[out] reg_data : Pointer to data buffer to store the read data.\n @param[in] len       : No of bytes of data to be read.\n @param[in,out] dev   : Structure instance of bme280_dev.\n\n @return Result of API execution status.\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_get_regs(reg_addr: u8, reg_data: *mut u8, len: u32, dev: *mut bme280_dev) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorSettings\n \\page bme280_api_bme280_set_sensor_settings bme280_set_sensor_settings\n \\code\n int8_t bme280_set_sensor_settings(uint8_t desired_settings, const struct bme280_settings *settings, struct bme280_dev *dev);\n \\endcode\n @details This API sets the oversampling, filter and standby duration\n (normal mode) settings in the sensor.\n\n @param[in] desired_settings  : Variable used to select the settings which\n                                are to be set in the sensor.\n @param[in] settings          : Structure instance of bme280_settings.\n @param[in] dev               : Structure instance of bme280_dev.\n\n @note : Below are the macros to be used by the user for selecting the\n desired settings. User can do OR operation of these macros for configuring\n multiple settings.\n\n@verbatim\n Macros                 |   Functionality\n -----------------------|----------------------------------------------\n BME280_SEL_OSR_PRESS   |   To set pressure oversampling.\n BME280_SEL_OSR_TEMP    |   To set temperature oversampling.\n BME280_SEL_OSR_HUM     |   To set humidity oversampling.\n BME280_SEL_FILTER      |   To set filter setting.\n BME280_SEL_STANDBY     |   To set standby duration setting.\n@endverbatim\n\n @return Result of API execution status\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_set_sensor_settings(
        desired_settings: u8,
        settings: *const bme280_settings,
        dev: *mut bme280_dev,
    ) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorSettings\n \\page bme280_api_bme280_get_sensor_settings bme280_get_sensor_settings\n \\code\n int8_t bme280_get_sensor_settings(struct bme280_settings *settings, struct bme280_dev *dev);\n \\endcode\n @details This API gets the oversampling, filter and standby duration\n (normal mode) settings from the sensor.\n\n @param[in] settings  : Structure instance of bme280_settings.\n @param[in,out] dev   : Structure instance of bme280_dev.\n\n @return Result of API execution status\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_get_sensor_settings(settings: *mut bme280_settings, dev: *mut bme280_dev) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorMode\n \\page bme280_api_bme280_set_sensor_mode bme280_set_sensor_mode\n \\code\n int8_t bme280_set_sensor_mode(uint8_t sensor_mode, const struct bme280_dev *dev);\n \\endcode\n @details This API sets the power mode of the sensor.\n\n @param[in] sensor_mode : Variable which contains the power mode to be set.\n @param[in] dev         : Structure instance of bme280_dev.\n\n@verbatim\n    sensor_mode       |      Macros\n ---------------------|-------------------------\n     0                | BME280_POWERMODE_SLEEP\n     1                | BME280_POWERMODE_FORCED\n     3                | BME280_POWERMODE_NORMAL\n@endverbatim\n\n @return Result of API execution status\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_set_sensor_mode(sensor_mode: u8, dev: *mut bme280_dev) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorMode\n \\page bme280_api_bme280_get_sensor_mode bme280_get_sensor_mode\n \\code\n int8_t bme280_get_sensor_mode(uint8_t *sensor_mode, struct bme280_dev *dev);\n \\endcode\n @details This API gets the power mode of the sensor.\n\n @param[out] sensor_mode : Pointer variable to store the power mode.\n @param[in] dev          : Structure instance of bme280_dev.\n\n@verbatim\n    sensor_mode       |      Macros\n ---------------------|-------------------------\n     0                | BME280_POWERMODE_SLEEP\n     1                | BME280_POWERMODE_FORCED\n     3                | BME280_POWERMODE_NORMAL\n@endverbatim\n\n @return Result of API execution status\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_get_sensor_mode(sensor_mode: *mut u8, dev: *mut bme280_dev) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSystem\n \\page bme280_api_bme280_soft_reset bme280_soft_reset\n \\code\n int8_t bme280_soft_reset(struct bme280_dev *dev);\n \\endcode\n @details This API soft-resets the sensor.\n\n @param[in,out] dev : Structure instance of bme280_dev.\n\n @return Result of API execution status.\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_soft_reset(dev: *mut bme280_dev) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorData\n \\page bme280_api_bme280_get_sensor_data bme280_get_sensor_data\n \\code\n int8_t bme280_get_sensor_data(uint8_t sensor_comp, struct bme280_data *comp_data, struct bme280_dev *dev);\n \\endcode\n @details This API reads the pressure, temperature and humidity data from the\n sensor, compensates the data and store it in the bme280_data structure\n instance passed by the user.\n\n @param[in] sensor_comp : Variable which selects which data to be read from\n the sensor.\n\n@verbatim\n sensor_comp |   Macros\n ------------|-------------------\n     1       | BME280_PRESS\n     2       | BME280_TEMP\n     4       | BME280_HUM\n     7       | BME280_ALL\n@endverbatim\n\n @param[out] comp_data : Structure instance of bme280_data.\n @param[in] dev        : Structure instance of bme280_dev.\n\n @return Result of API execution status\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_get_sensor_data(
        sensor_comp: u8,
        comp_data: *mut bme280_data,
        dev: *mut bme280_dev,
    ) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorData\n \\page bme280_api_bme280_compensate_data bme280_compensate_data\n \\code\n int8_t bme280_compensate_data(uint8_t sensor_comp,\n                             const struct bme280_uncomp_data *uncomp_data,\n                             struct bme280_data *comp_data,\n                             struct bme280_calib_data *calib_data);\n \\endcode\n @details This API is used to compensate the pressure and/or\n temperature and/or humidity data according to the component selected by the\n user.\n\n @param[in] sensor_comp : Used to select pressure and/or temperature and/or\n                          humidity.\n @param[in] uncomp_data : Contains the uncompensated pressure, temperature and\n                          humidity data.\n @param[out] comp_data  : Contains the compensated pressure and/or temperature\n                          and/or humidity data.\n @param[in] calib_data  : Pointer to bme280_calib_data\n\n @return Result of API execution status.\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_compensate_data(
        sensor_comp: u8,
        uncomp_data: *const bme280_uncomp_data,
        comp_data: *mut bme280_data,
        calib_data: *mut bme280_calib_data,
    ) -> i8;
}
extern "C" {
    #[doc = " \\ingroup bme280ApiSensorDelay\n \\page bme280_api_bme280_cal_meas_delay bme280_cal_meas_delay\n \\code\n uint32_t bme280_cal_meas_delay(uint32_t *max_delay, const struct bme280_settings *settings);\n \\endcode\n\n @details This API is used to calculate the maximum delay in microseconds required for the\n temperature/pressure/humidity(whichever are enabled) measurement to complete.\n The delay depends upon the number of sensors enabled and their oversampling configuration.\n\n @param[out] max_delay  : Delay required in microseconds.\n @param[in] settings    : Contains the oversampling configurations.\n\n @return Result of API execution status.\n\n @retval   0 -> Success.\n @retval > 0 -> Warning.\n @retval < 0 -> Fail.\n"]
    pub fn bme280_cal_meas_delay(max_delay: *mut u32, settings: *const bme280_settings) -> i8;
}
